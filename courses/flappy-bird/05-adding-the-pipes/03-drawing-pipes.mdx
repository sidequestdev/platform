---
sidebar_position: 3
title: Drawing Pipes
---

# Drawing Pipes

## Pipe Entity

Lets create a new `Pipe` entity:

```ts title="src/entities/pipe.ts"
import { SpriteData } from "#/components/sprite-data";
import { Vector2d } from "#/components/vector2d";
import { Game } from "#/game";

type PipeOptions = {
  game: Game;
  position: Vector2d;
  rimSpriteData: SpriteData;
  sliceSpriteData: SpriteData;
  spriteSheet: HTMLImageElement;
  type: "top" | "bottom";
};

export class Pipe {
  game: Game;
  position: Vector2d;
  rimSpriteData: SpriteData;
  sliceSpriteData: SpriteData;
  spriteSheet: HTMLImageElement;
  type: "top" | "bottom";

  constructor(options: PipeOptions) {
    this.game = options.game;
    this.position = options.position;
    this.rimSpriteData = options.rimSpriteData;
    this.sliceSpriteData = options.sliceSpriteData;
    this.spriteSheet = options.spriteSheet;
    this.type = options.type;
  }

  public draw(context: CanvasRenderingContext2D) {}
}
```

Not much new here except our usage of a TypeScript union type.

<AlertInfo title="Unions">Add blurb about `"top" | "bottom"`</AlertInfo>

## Pipe Positioning

Before we instantiate our pipes, I want to talk a little bit about how we're going to position them. We'll describe the positions _relative_ to the center of the canvas - which will later be substituted for our spawn point. More importantly, relative to the `y` position of the center of the canvas. I call out `y` because later we'll spawn the pipes off screen in `x` so they can _scroll_ into the gameplay area.

This feels more intuitive than describing the top left corners of the images we'll be drawing. The pipes will handle the details in the `draw` method.

This diagram demonstrates the positioning of the pipes:

<ThemeImage
  alt="Pipes positioning diagram"
  width="358"
  height="369"
  light={{
    src: "/images/courses/flappy-bird/05-adding-the-pipes/pipes-positioning-light.png",
  }}
  dark={{
    src: "/images/courses/flappy-bird/05-adding-the-pipes/pipes-positioning-dark.png",
  }}
/>

With that, let's instantiate our pipes:

```ts title="src/main.ts" +{11,17-39}
import spriteSheetUrl from "#/assets/image/spritesheet.png";
import { BoxCollider } from "#/components/box-collider";
import { CircleCollider } from "#/components/circle-collider";
import { SpriteAnimation } from "#/components/sprite-animation";
import { SpriteAnimationDetails } from "#/components/sprite-animation-details";
import { SpriteData } from "#/components/sprite-data";
import { Vector2d } from "#/components/vector2d";
import { config } from "#/config";
import { Bird } from "#/entities/bird";
import { Ground } from "#/entities/ground";
import { Pipe } from "#/entities/pipe";
import { Game, GameState } from "#/game";
import { loadImage } from "#/lib/asset-loader";
import { circleRectangleIntersects } from "#/lib/collision";
import { spriteMap } from "#/sprite-map";

const pipeTop = new Pipe({
  game,
  position: new Vector2d(
    config.gameWidth / 2 - spriteMap.pipes.green.slice.width / 2,
    config.gameHeight / 2 - 50
  ),
  rimSpriteData: spriteMap.pipes.green.bottom,
  sliceSpriteData: spriteMap.pipes.green.slice,
  spriteSheet,
  type: "top",
});

const pipeBottom = new Pipe({
  game,
  position: new Vector2d(
    config.gameWidth / 2 - spriteMap.pipes.green.slice.width / 2,
    config.gameHeight / 2 + 50
  ),
  rimSpriteData: spriteMap.pipes.green.top,
  sliceSpriteData: spriteMap.pipes.green.slice,
  spriteSheet,
  type: "bottom",
});

let last = performance.now();
```

Note our positions. For the top and bottom pipe, we use the same `x` position of: `config.gameWidth / 2 - spriteMap.pipes.green.slice.width / 2`. Half the game width minus half the width of the slice sprite.

The `y` position is very similar. Half the game height plus/minus the buffer of `50` pixels.

Note that we pass the rim sprite data that is opposite the pipe _type_. So when we draw a `top` pipe, we draw the `bottom` rim sprite. And vice versa.

## Drawing a Few Helpers

Let's add a few reference lines to the canvas to help make sure we get our positioning correct.

Add this after the `ground.draw(context)` within the `frame` function:

```ts title="src/main.ts"
const x = config.gameWidth / 2 - spriteMap.pipes.green.slice.width / 2;
const y = config.gameHeight / 2;
const buffer = 50;
const lineLength = 65;

// Where the bottom of the top pipe will be
context.fillStyle = "red";
context.fillRect(x, y - buffer, lineLength, 1);
// Center of the canvas (our spawn point)
context.fillStyle = "purple";
context.fillRect(x, y, lineLength, 1);
// Where the top of the bottom pipe will be
context.fillStyle = "red";
context.fillRect(x, y + buffer, lineLength, 1);
```

You should now see three lines drawn on the canvas:

<ThemeImage
  alt="Pipes reference lines diagram"
  width="352"
  height="576"
  light={{
    src: "/images/courses/flappy-bird/05-adding-the-pipes/with-pipe-reference-lines.png",
  }}
  dark={{
    src: "/images/courses/flappy-bird/05-adding-the-pipes/with-pipe-reference-lines.png",
  }}
/>

## The Height Property

Before we can finally draw the pipes, we need to know the _height_ of the pipe. We have all the information needed, we just need to determine and store the value in the `Pipe` class:

```ts title="src/entities/pipe.ts" +{2,18-21}
export class Pipe {
  height: number;
  game: Game;
  position: Vector2d;
  rimSpriteData: SpriteData;
  sliceSpriteData: SpriteData;
  spriteSheet: HTMLImageElement;
  type: "top" | "bottom";

  constructor(options: PipeOptions) {
    this.game = options.game;
    this.position = options.position;
    this.rimSpriteData = options.rimSpriteData;
    this.sliceSpriteData = options.sliceSpriteData;
    this.spriteSheet = options.spriteSheet;
    this.type = options.type;

    this.height =
      this.type === "top"
        ? this.position.y
        : this.game.config.gameHeight - this.position.y;
  }

  public draw(context: CanvasRenderingContext2D) {}
}
```

When we are drawing the `top` pipe, we want the height to be the distance from the top of the canvas (0) to the `y` position. Or just `position.y`, since that's the same value.

When we are drawing the `bottom` pipe, we want the height to be the distance from the bottom of the canvas (`config.gameHeight`) to the `y` position, so we subtract.

The reference lines we drew earlier can help you visualize that distance. We can finally draw the pipes!

## Drawing the Pipe Rims

Let's add our pipe draw calls to the `frame` function:

```ts title="src/main.ts" +{2,3}
bird.draw(context);
pipeTop.draw(context);
pipeBottom.draw(context);
ground.draw(context);
```

We haven't done anything to draw the pipes yet. We'll add the logic in the `draw` method next.

Let's start with drawing the proper _rim_ of the pipe.

```ts title="src/entities/pipe.ts" +{5-17}
export class Pipe {
  // ...

  public draw(context: CanvasRenderingContext2D) {
    context.drawImage(
      this.spriteSheet,
      this.rimSpriteData.sourceX,
      this.rimSpriteData.sourceY,
      this.rimSpriteData.width,
      this.rimSpriteData.height,
      this.position.x,
      this.type === "top"
        ? this.height - this.rimSpriteData.height
        : this.position.y,
      this.rimSpriteData.width,
      this.rimSpriteData.height
    );
  }
}
```

Let focus on the logic for the destination `y` position of the draw call. The rest we've seen before.

We draw the rim of the pipe at a slightly different `y` position, based on the `type`. When the `type` is `"top"`, we need to offset the position of the draw call by the height of the rim sprite: `height - rimSpriteData.height`. When the `type` is `"bottom"`, we don't need to perform any changes.

Recall that the destination position we provide to `drawImage` is the top left corner of the image, that's why we perform this adjustment.

If you look at the canvas, you should see the pipe rims drawn at the correct positions. Right in line with our reference lines.

## Drawing the Pipe Body

Lastly we need to draw the _body_ of the pipe.

```ts title="src/entities/pipe.ts" +{17-41}
export class Pipe {
  public draw(context: CanvasRenderingContext2D) {
    context.drawImage(
      this.spriteSheet,
      this.rimSpriteData.sourceX,
      this.rimSpriteData.sourceY,
      this.rimSpriteData.width,
      this.rimSpriteData.height,
      this.position.x,
      this.type === "top"
        ? this.height - this.rimSpriteData.height
        : this.position.y,
      this.rimSpriteData.width,
      this.rimSpriteData.height
    );

    if (this.type === "top") {
      context.drawImage(
        this.spriteSheet,
        this.sliceSpriteData.sourceX,
        this.sliceSpriteData.sourceY,
        this.sliceSpriteData.width,
        this.sliceSpriteData.height,
        this.position.x,
        0,
        this.sliceSpriteData.width,
        this.height - this.rimSpriteData.height
      );
    } else {
      context.drawImage(
        this.spriteSheet,
        this.sliceSpriteData.sourceX,
        this.sliceSpriteData.sourceY,
        this.sliceSpriteData.width,
        this.sliceSpriteData.height,
        this.position.x,
        this.position.y + this.rimSpriteData.height,
        this.sliceSpriteData.width,
        this.height - this.rimSpriteData.height
      );
    }
  }
}
```

Let's start with the top. We need the body of the pipe to be drawn from a `y` position of `0`, and a hieght of _pipe_ `height` minus `rimSpriteData.height`. Try removing `- this.rimSpriteData.height` and you'll see how the body is now in front of the pipe rim. Drawing the body last was intentional to help callout potential rendering issues overlapping the rim.

When we draw the bottom, we need the body to be drawn from the `y` position and offset positively (down) by `rimSpriteData.height` with a height of _pipe_ `height` minus `rimSpriteData.height`. Technically we don't need to subtract the `rimSpriteData.height` from the destination height. It would just draw off the bottom of the canvas, but we'll leave it for consistency sake.

Lets move on to adding some colliders.
